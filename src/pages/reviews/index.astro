---
export const prerender = true;

import Layout from "@/layouts/Layout.astro";
import Card from "@/components/Card.astro";

// Fetch data
const reviewsData = await fetch("https://cms.theadhocracy.co.uk/reviews.json", {
	method: "GET",
	headers: {
		"content-type": "application/json",
		Authorization: `Bearer ${import.meta.env.CRAFT_API_KEY}`,
	},
});
const reviewsResponse = await reviewsData.json();

const seriesData = await fetch("https://cms.theadhocracy.co.uk/series.json", {
	method: "GET",
	headers: {
		"content-type": "application/json",
		Authorization: `Bearer ${import.meta.env.CRAFT_API_KEY}`,
	},
});
const seriesResponse = await seriesData.json();

const collectionData = await fetch(
	"https://cms.theadhocracy.co.uk/collections.json",
	{
		method: "GET",
		headers: {
			"content-type": "application/json",
			Authorization: `Bearer ${import.meta.env.CRAFT_API_KEY}`,
		},
	}
);
const collectionResponse = await collectionData.json();

// Set root pathways for data
const reviews = reviewsResponse.data.slice(0, 6);

const series = seriesResponse.data
	.sort((a: any, b: any) => {
		// Gets the most recently updated review for each series, and sorts in descending order (so most recent review first)
		const aUpdated = a.reviews?.reduce((prev: any, current: any) => {
			return prev && prev.updated > current.updated ? prev : current;
		}, null);

		const bUpdated = b.reviews?.reduce((prev: any, current: any) => {
			return prev && prev.updated > current.updated ? prev : current;
		}, null);

		return Date.parse(bUpdated?.updated) - Date.parse(aUpdated?.updated);
	})
	.slice(0, 6);

const collections = collectionResponse.data
	.sort((a: any, b: any) => {
		// Gets the most recently updated review for each series, and sorts in descending order (so most recent review first)
		const aUpdated = a.reviews?.reduce((prev: any, current: any) => {
			return prev && prev.updated > current.updated ? prev : current;
		}, null);

		const bUpdated = b.reviews?.reduce((prev: any, current: any) => {
			return prev && prev.updated > current.updated ? prev : current;
		}, null);

		return Date.parse(bUpdated?.updated) - Date.parse(aUpdated?.updated);
	})
	.slice(0, 6);
---

<Layout title="Reviews">
	<section id="content">
		<header>
			<h1>Latest Reviews</h1>
		</header>
		<section class="content-grid">
			{
				reviews.map((review: any) => {
					return <Card post={review} type="review" />;
				})
			}
		</section>
		<a class="bold-link" href="/reviews/1"> Explore All Reviews? </a>
		<p class="banner-text">
			⬇ Otherwise, you can <a href="#search">search reviews</a> or check out the
			latest updates to <a href="#series">series</a> and <a href="#collections"
				>collections</a
			> ⬇
		</p>
		<h2 id="series">Series Updates</h2>
		<section class="content-grid">
			{
				series.map((review: any) => {
					return <Card post={review} type="review" />;
				})
			}
		</section>
		<h2 id="collections">Collection Updates</h2>
		<section class="content-grid">
			{
				collections.map((review: any) => {
					return <Card post={review} type="review" />;
				})
			}
		</section>
		<h2 id="search">Search All Reviews</h2>
		<!-- <InstantSearch indexName={searchIndex} searchClient={searchClient}>
            <CustomSearchBox defaultRefinement={urlQuery} label="reviews" />
            <Configure hitsPerPage={"6"} />
            <section class="search_control">
                <CustomCategoryFilter attribute="node.type" limit={50} />
                <CustomRatingMenu attribute="node.rating" />
            </section>
            <ReviewPreview />
        </InstantSearch> -->
	</section>
</Layout>

<style is:global>
	/* Header */
	.review-header > div {
		max-width: var(--main);
		padding-bottom: 1rem;
	}

	/* Series & Collections */

	.article .collections a,
	.article .collections a:visited {
		display: inline-block;
		padding: 0.5rem;
		border: 2px solid var(--blue);
		border-radius: 6px;
		text-decoration: none;
		line-height: 0.6;
		color: var(--blue);
	}

	.collections a + a {
		margin-left: 1rem;
	}

	.article .review-header p.collections a:hover,
	.article .review-header p.collections a:focus {
		font-style: normal;
		letter-spacing: normal;
		color: #ffffff;
		background-color: var(--blue);
	}

	/* Series Navigation */

	.series-nav {
		width: var(--main);
		max-width: calc(100% + 1rem);
	}

	nav.series-nav ul {
		display: flex;
		flex-wrap: wrap;
		justify-content: flex-start;
		align-items: baseline;
		margin-left: -1rem;
		margin-bottom: -0.5rem;
	}

	.series-nav ul li {
		margin: 0;
		margin-left: 1rem;
		margin-bottom: 0.5rem;
		padding: 0;
	}

	.series-nav li a {
		display: inline-block;
		padding: 0.5rem;
		border: 2px solid var(--green);
		border-radius: 6px;
		text-decoration: none;
		line-height: 0.6;
		color: var(--green);
	}

	.article nav.series-nav ul li a:hover {
		font-style: normal;
		letter-spacing: normal;
		background-color: var(--green);
		color: #ffffff;
	}

	.series-nav a.active-series,
	.series-nav a.active-series:visited,
	.series-nav a.active-series:active {
		background-color: var(--green);
		color: #ffffff;
	}

	.series-nav ul:hover a.active-series {
		background-color: #ffffff;
		color: var(--green);
	}

	/* Homepage */

	/* Search */

	.search_control {
		display: flex;
		flex-wrap: wrap;
		align-items: center;
	}

	.search_control > ul {
		margin-right: 2rem;
	}

	.search_control span.label {
		margin-right: 0.5rem;
		text-transform: uppercase;
		font-size: 0.8rem;
		font-weight: bold;
		color: var(--orange);
	}
</style>
